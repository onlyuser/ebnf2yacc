(grammar (definitions (decl_eq name-prefix "_XLANG_") (proto_block "\n\n#include \"XLang.h\" // node::NodeIdentIFace\n#include \"XLang.tab.h\" // ID_XXX (yacc generated)\n#include \"XLangAlloc.h\" // Allocator\n#include \"mvc/XLangMVCView.h\" // mvc::MVCView\n#include \"mvc/XLangMVCModel.h\" // mvc::MVCModel\n#include \"XLangTreeContext.h\" // TreeContext\n#include \"XLangType.h\" // uint32_t\n#include <stdio.h> // size_t\n#include <stdarg.h> // va_start\n#include <string> // std::string\n#include <sstream> // std::stringstream\n#include <iostream> // std::cout\n#include <stdlib.h> // EXIT_SUCCESS\n#include <getopt.h> // getopt_long\n\n#define MAKE_TERM(lexer_id, ...)   xl::mvc::MVCModel::make_term(tree_context(), lexer_id, ##__VA_ARGS__)\n#define MAKE_SYMBOL(...)         xl::mvc::MVCModel::make_symbol(tree_context(), ##__VA_ARGS__)\n#define ERROR_LEXER_ID_NOT_FOUND   \"missing lexer_id handler, most likely you forgot to register one\"\n#define ERROR_LEXER_NAME_NOT_FOUND \"missing sym name handler, most likely you forgot to register one\"\n\n// report error\nvoid _XLANG_error(const char* s)\n{\n    errors() << s;\n}\n\n// get resource\nstd::stringstream &errors()\n{\n    static std::stringstream _errors;\n    return _errors;\n}\nstd::string id_to_name(uint32_t lexer_id)\n{\n    static const char* _id_to_name[] = {\n        \"int\",\n        \"float\",\n        \"ident\"\n        };\n    int index = static_cast<int>(lexer_id)-ID_BASE-1;\n    if(index >= 0 && index < static_cast<int>(sizeof(_id_to_name)/sizeof(*_id_to_name)))\n        return _id_to_name[index];\n    switch(lexer_id)\n    {\n        case ID_UMINUS: return \"uminus\";\n        case \'+\':       return \"+\";\n        case \'-\':       return \"-\";\n        case \'*\':       return \"*\";\n        case \'/\':       return \"/\";\n        case \'=\':       return \"=\";\n        case \',\':       return \",\";\n    }\n    throw ERROR_LEXER_ID_NOT_FOUND;\n    return \"\";\n}\nuint32_t name_to_id(std::string name)\n{\n    if(name == \"int\")    return ID_INT;\n    if(name == \"float\")  return ID_FLOAT;\n    if(name == \"ident\")  return ID_IDENT;\n    if(name == \"uminus\") return ID_UMINUS;\n    if(name == \"+\")      return \'+\';\n    if(name == \"-\")      return \'-\';\n    if(name == \"*\")      return \'*\';\n    if(name == \"/\")      return \'/\';\n    if(name == \"=\")      return \'=\';\n    if(name == \",\")      return \',\';\n    throw ERROR_LEXER_NAME_NOT_FOUND;\n    return 0;\n}\nxl::TreeContext* &tree_context()\n{\n    static xl::TreeContext* tc = NULL;\n    return tc;\n}\n\n") (decl union (union_block (decl_stmts (decl_stmt (decl_chunks (decl_chunk "xl::node::TermInternalType<xl::node::NodeIdentIFace::INT>::type") (decl_chunk "int_value"))) (decl_stmt (decl_chunks (decl_chunk "xl::node::TermInternalType<xl::node::NodeIdentIFace::FLOAT>::type") (decl_chunk "float_value"))) (decl_stmt (decl_chunks (decl_chunk "xl::node::TermInternalType<xl::node::NodeIdentIFace::IDENT>::type") (decl_chunk "ident_value"))) (decl_stmt (decl_chunks (decl_chunk "xl::node::TermInternalType<xl::node::NodeIdentIFace::SYMBOL>::type") (decl_chunk "symbol_value")))))) (decl error-verbose) (decl nonassoc (symbols (symbol ID_BASE))) (decl_brace token int_value (symbols (symbol ID_INT))) (decl_brace token float_value (symbols (symbol ID_FLOAT))) (decl_brace token ident_value (symbols (symbol ID_IDENT))) (decl_brace type symbol_value (symbols (symbol program) (symbol statement) (symbol expression))) (decl left (symbols (symbol '+') (symbol '-'))) (decl left (symbols (symbol '*') (symbol '/'))) (decl nonassoc (symbols (symbol ID_UMINUS)))) (rules (rule root (alts (alt (terms program) (action_block " tree_context()->root() = $1; YYACCEPT; ")) (alt (terms error) (action_block " yyclearin; /* yyerrok; YYABORT; */ ")))) (rule program (alts (alt (terms statement) (action_block " $$ = $1; ")) (alt (terms program ',' statement) (action_block " $$ = MAKE_SYMBOL(\',\', 2, $1, $3); ")))) (rule statement (alts (alt (terms expression) (action_block " $$ = $1; ")) (alt (terms ID_IDENT '=' expression) (action_block " $$ = MAKE_SYMBOL(\'=\', 2, MAKE_TERM(ID_IDENT, $1), $3); ")))) (rule expression (alts (alt (terms ID_INT) (action_block " $$ = MAKE_TERM(ID_INT, $1); ")) (alt (terms ID_FLOAT) (action_block " $$ = MAKE_TERM(ID_FLOAT, $1); ")) (alt (terms ID_IDENT) (action_block " $$ = MAKE_TERM(ID_IDENT, $1); ")) (alt (terms '-' expression %prec ID_UMINUS) (action_block " $$ = MAKE_SYMBOL(ID_UMINUS, 1, $2); ")) (alt (terms expression '+' expression) (action_block " $$ = MAKE_SYMBOL(\'+\', 2, $1, $3); ")) (alt (terms expression '-' expression) (action_block " $$ = MAKE_SYMBOL(\'-\', 2, $1, $3); ")) (alt (terms expression '*' expression) (action_block " $$ = MAKE_SYMBOL(\'*\', 2, $1, $3); ")) (alt (terms expression '/' expression) (action_block " $$ = MAKE_SYMBOL(\'/\', 2, $1, $3); ")) (alt (terms '(' expression ')') (action_block " $$ = $2; "))))) (code "\n\nxl::node::NodeIdentIFace* make_ast(xl::Allocator &alloc)\n{\n    tree_context() = new (PNEW(alloc, xl::, TreeContext)) xl::TreeContext(alloc);\n    int error = _XLANG_parse(); // parser entry point\n    _XLANG_lex_destroy();\n    return (!error && errors().str().empty()) ? tree_context()->root() : NULL;\n}\n\nvoid display_usage(bool verbose)\n{\n    std::cout << \"Usage: XLang [-i] OPTION [-m]\" << std::endl;\n    if(verbose)\n    {\n        std::cout << \"Parses input and prints a syntax tree to standard out\" << std::endl\n                << std::endl\n                << \"Input control:\" << std::endl\n                << \"  -i, --in-xml=FILE (de-serialize from xml)\" << std::endl\n                << std::endl\n                << \"Output control:\" << std::endl\n                << \"  -l, --lisp\" << std::endl\n                << \"  -x, --xml\" << std::endl\n                << \"  -g, --graph\" << std::endl\n                << \"  -d, --dot\" << std::endl\n                << \"  -m, --memory\" << std::endl\n                << \"  -h, --help\" << std::endl;\n    }\n    else\n        std::cout << \"Try `XLang --help\\\' for more information.\" << std::endl;\n}\n\nstruct args_t\n{\n    typedef enum\n    {\n        MODE_NONE,\n        MODE_LISP,\n        MODE_XML,\n        MODE_GRAPH,\n        MODE_DOT,\n        MODE_HELP\n    } mode_e;\n\n    mode_e mode;\n    std::string in_xml;\n    bool dump_memory;\n\n    args_t()\n        : mode(MODE_NONE), dump_memory(false)\n    {}\n};\n\nbool parse_args(int argc, char** argv, args_t &args)\n{\n    int opt = 0;\n    int longIndex = 0;\n    static const char *optString = \"i:lxgdmh?\";\n    static const struct option longOpts[] = {\n                { \"in-xml\", required_argument, NULL, \'i\' },\n                { \"lisp\",   no_argument,       NULL, \'l\' },\n                { \"xml\",    no_argument,       NULL, \'x\' },\n                { \"graph\",  no_argument,       NULL, \'g\' },\n                { \"dot\",    no_argument,       NULL, \'d\' },\n                { \"memory\", no_argument,       NULL, \'m\' },\n                { \"help\",   no_argument,       NULL, \'h\' },\n                { NULL,     no_argument,       NULL, 0 }\n            };\n    opt = getopt_long(argc, argv, optString, longOpts, &longIndex);\n    while(opt != -1)\n    {\n        switch(opt)\n        {\n            case \'i\': args.in_xml = optarg; break;\n            case \'l\': args.mode = args_t::MODE_LISP; break;\n            case \'x\': args.mode = args_t::MODE_XML; break;\n            case \'g\': args.mode = args_t::MODE_GRAPH; break;\n            case \'d\': args.mode = args_t::MODE_DOT; break;\n            case \'m\': args.dump_memory = true; break;\n            case \'h\':\n            case \'?\': args.mode = args_t::MODE_HELP; break;\n            case 0: // reserved\n            default:\n                break;\n        }\n        opt = getopt_long(argc, argv, optString, longOpts, &longIndex);\n    }\n    if(args_t::MODE_NONE == args.mode && !args.dump_memory)\n    {\n        display_usage(false);\n        return false;\n    }\n    return true;\n}\n\nbool import_ast(args_t &args, xl::Allocator &alloc, xl::node::NodeIdentIFace* &ast)\n{\n    if(args.in_xml != \"\")\n    {\n        ast = xl::mvc::MVCModel::make_ast(\n                new (PNEW(alloc, xl::, TreeContext)) xl::TreeContext(alloc),\n                args.in_xml);\n        if(!ast)\n        {\n            std::cout << \"de-serialize from xml fail!\" << std::endl;\n            return false;\n        }\n    }\n    else\n    {\n        ast = make_ast(alloc);\n        if(!ast)\n        {\n            std::cout << errors().str().c_str() << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid export_ast(args_t &args, const xl::node::NodeIdentIFace* ast)\n{\n    switch(args.mode)\n    {\n        case args_t::MODE_LISP:  xl::mvc::MVCView::print_lisp(ast); break;\n        case args_t::MODE_XML:   xl::mvc::MVCView::print_xml(ast); break;\n        case args_t::MODE_GRAPH: xl::mvc::MVCView::print_graph(ast); break;\n        case args_t::MODE_DOT:   xl::mvc::MVCView::print_dot(ast); break;\n        default:\n            break;\n    }\n}\n\nbool do_work(args_t &args)\n{\n    try\n    {\n        if(args.mode == args_t::MODE_HELP)\n        {\n            display_usage(true);\n            return true;\n        }\n        xl::Allocator alloc(__FILE__);\n        xl::node::NodeIdentIFace* ast = NULL;\n        if(!import_ast(args, alloc, ast))\n            return false;\n        export_ast(args, ast);\n        if(args.dump_memory)\n            alloc.dump(std::string(1, \'\\t\'));\n    }\n    catch(const char* s)\n    {\n        std::cout << \"ERROR: \" << s << std::endl;\n        return false;\n    }\n    return true;\n}\n\nint main(int argc, char** argv)\n{\n    args_t args;\n    if(!parse_args(argc, argv, args))\n        return EXIT_FAILURE;\n    if(!do_work(args))\n        return EXIT_FAILURE;\n    return EXIT_SUCCESS;\n}\n"))
